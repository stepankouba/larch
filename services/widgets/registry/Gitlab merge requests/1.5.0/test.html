<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>ReQL command: update</title>
<link rel="stylesheet" href="rethinkdb.css">
</head>
<body>
<div id="wrapper">
<div id="header">
<h1 class="title">ReQL command: update</h1>
</div>
<h1 id="command-syntax">Command syntax</h1>
<pre class="api"><code>table.update(object | expr[, {durability: "hard", returnChanges: false, nonAtomic: false}])
    &rarr; object
selection.update(object | expr[, {durability: "hard", returnChanges: false, nonAtomic: false}])
    &rarr; object
singleSelection.update(object | expr[, {durability: "hard", returnChanges: false, nonAtomic: false}])
    &rarr; object
</code></pre>
<h1 id="description">Description</h1>
<p>Update JSON documents in a table. Accepts a JSON document, a ReQL expression, or a combination of the two.</p>
<p>The optional arguments are:</p>
<ul>
<li><code>durability</code>: possible values are <code>hard</code> and <code>soft</code>. This option will override the table or query's durability setting (set in <a href="run.html">run</a>). In soft durability mode RethinkDB will acknowledge the write immediately after receiving it, but before the write has been committed to disk.</li>
<li><code>returnChanges</code>:
<ul>
<li><code>true</code>: return a <code>changes</code> array consisting of <code>old_val</code>/<code>new_val</code> objects describing the changes made, only including the documents actually updated.</li>
<li><code>false</code>: do not return a <code>changes</code> array (the default).</li>
<li><code>&quot;always&quot;</code>: behave as <code>true</code>, but include all documents the command tried to update whether or not the update was successful. (This was the behavior of <code>true</code> pre-2.0.)</li>
</ul></li>
<li><code>nonAtomic</code>: if set to <code>true</code>, executes the update and distributes the result to replicas in a non-atomic fashion. This flag is required to perform non-deterministic updates, such as those that require reading data from another table.</li>
</ul>
<p>Update returns an object that contains the following attributes:</p>
<ul>
<li><code>replaced</code>: the number of documents that were updated.</li>
<li><code>unchanged</code>: the number of documents that would have been modified except the new value was the same as the old value.</li>
<li><code>skipped</code>: the number of documents that were skipped because the document didn't exist.</li>
<li><code>errors</code>: the number of errors encountered while performing the update.</li>
<li><code>first_error</code>: If errors were encountered, contains the text of the first error.</li>
<li><code>deleted</code> and <code>inserted</code>: 0 for an update operation.</li>
<li><code>changes</code>: if <code>returnChanges</code> is set to <code>true</code>, this will be an array of objects, one for each objected affected by the <code>update</code> operation. Each object will have two keys: <code>{new_val: &lt;new value&gt;, old_val: &lt;old value&gt;}</code>.</li>
</ul>
<p><strong>Example:</strong> Update the status of the post with <code>id</code> of <code>1</code> to <code>published</code>.</p>
<pre class="js"><code>r.table(&quot;posts&quot;).get(1).update({status: &quot;published&quot;}).run(conn, callback)</code></pre>
<p><strong>Example:</strong> Update the status of all posts to <code>published</code>.</p>
<pre class="js"><code>r.table(&quot;posts&quot;).update({status: &quot;published&quot;}).run(conn, callback)</code></pre>
<p><strong>Example:</strong> Update the status of all the posts written by William.</p>
<pre class="js"><code>r.table(&quot;posts&quot;).filter({author: &quot;William&quot;}).update({status: &quot;published&quot;}).run(conn, callback)</code></pre>
<p><strong>Example:</strong> Increment the field <code>view</code> with <code>id</code> of <code>1</code>. This query will throw an error if the field <code>views</code> doesn't exist.</p>
<pre class="js"><code>r.table(&quot;posts&quot;).get(1).update({
    views: r.row(&quot;views&quot;).add(1)
}).run(conn, callback)</code></pre>
<p><strong>Example:</strong> Increment the field <code>view</code> of the post with <code>id</code> of <code>1</code>. If the field <code>views</code> does not exist, it will be set to <code>0</code>.</p>
<pre class="js"><code>r.table(&quot;posts&quot;).update({
    views: r.row(&quot;views&quot;).add(1).default(0)
}).run(conn, callback)</code></pre>
<p><strong>Example:</strong> Perform a conditional update.<br />
If the post has more than 100 views, set the <code>type</code> of a post to <code>hot</code>, else set it to <code>normal</code>.</p>
<pre class="js"><code>r.table(&quot;posts&quot;).get(1).update(function(post) {
    return r.branch(
        post(&quot;views&quot;).gt(100),
        {type: &quot;hot&quot;},
        {type: &quot;normal&quot;}
    )
}).run(conn, callback)</code></pre>
<p><strong>Example:</strong> Update the field <code>numComments</code> with the result of a sub-query. Because this update is not atomic, you must pass the <code>nonAtomic</code> flag.</p>
<pre class="js"><code>r.table(&quot;posts&quot;).get(1).update({
    numComments: r.table(&quot;comments&quot;).filter({idPost: 1}).count()
}, {
    nonAtomic: true
}).run(conn, callback)</code></pre>
<p>If you forget to specify the <code>nonAtomic</code> flag, you will get a <code>RqlRuntimeError</code>:</p>
<pre><code>RqlRuntimeError: Could not prove function deterministic.  Maybe you want to use the non_atomic flag? </code></pre>
<p><strong>Example:</strong> Update the field <code>numComments</code> with a random value between 0 and 100. This update cannot be proven deterministic because of <code>r.js</code> (and in fact is not), so you must pass the <code>nonAtomic</code> flag.</p>
<pre class="js"><code>r.table(&quot;posts&quot;).get(1).update({
    num_comments: r.js(&quot;Math.floor(Math.random()*100)&quot;)
}, {
    nonAtomic: true
}).run(conn, callback)</code></pre>
<p><strong>Example:</strong> Update the status of the post with <code>id</code> of <code>1</code> using soft durability.</p>
<pre class="js"><code>r.table(&quot;posts&quot;).get(1).update({status: &quot;published&quot;}, {durability: &quot;soft&quot;}).run(conn, callback)</code></pre>
<p><strong>Example:</strong> Increment the field <code>views</code> and return the values of the document before and after the update operation.</p>
<pre class="js"><code>r.table(&quot;posts&quot;).get(1).update({
    views: r.row(&quot;views&quot;).add(1)
}, {
    returnChanges: true
}).run(conn, callback)</code></pre>
<p>The result will now include a <code>changes</code> field:</p>
<pre class="js"><code>{
    deleted: 1,
    errors: 0,
    inserted: 0,
    changes: [
        {
            new_val: {
                id: 1,
                author: &quot;Julius_Caesar&quot;,
                title: &quot;Commentarii de Bello Gallico&quot;,
                content: &quot;Aleas jacta est&quot;,
                views: 207
            },
            old_val: {
                id: 1,
                author: &quot;Julius_Caesar&quot;,
                title: &quot;Commentarii de Bello Gallico&quot;,
                content: &quot;Aleas jacta est&quot;,
                views: 206
            }
        }
    ],
    replaced: 0,
    skipped: 0,
    unchanged: 0
}</code></pre>
<h2 id="updating-nested-fields">Updating nested fields</h2>
<p>The <code>update</code> command supports RethinkDB's <a href="/docs/nested-fields/javascript">nested field</a> syntax to update subdocuments. Consider a user table with contact information in this format:</p>
<pre class="js"><code>{
    id: 10001,
    name: &quot;Bob Smith&quot;,
    contact: {
        phone: {
            work: &quot;408-555-1212&quot;,
            home: &quot;408-555-1213&quot;,
            cell: &quot;408-555-1214&quot;
        },
        email: {
            work: &quot;bob@smith.com&quot;,
            home: &quot;bobsmith@example.com&quot;,
            other: &quot;bobbys@moosecall.net&quot;
        },
        im: {
            skype: &quot;Bob Smith&quot;,
            aim: &quot;bobmoose&quot;,
            icq: &quot;nobodyremembersicqnumbers&quot;
        }
    },
    notes: [
        {
            date: r.time(2014,1,1,&#39;Z&#39;),
            from: &quot;John Doe&quot;,
            subject: &quot;My name is even more boring than Bob&#39;s&quot;
        },
        {
            date: r.time(2014,2,2,&#39;Z&#39;),
            from: &quot;Bob Smith Sr&quot;,
            subject: &quot;Happy Second of February&quot;
        }
    ]
}</code></pre>
<p><strong>Example:</strong> Update Bob Smith's cell phone number.</p>
<pre class="js"><code>r.table(&quot;users&quot;).get(10001).update(
    {contact: {phone: {cell: &quot;408-555-4242&quot;}}}
).run(conn, callback)</code></pre>
<p><strong>Example:</strong> Add another note to Bob Smith's record.</p>
<pre class="js"><code>var newNote = {
    date: r.now(),
    from: &quot;Inigo Montoya&quot;,
    subject: &quot;You killed my father&quot;
};
r.table(&quot;users&quot;).get(10001).update(
    {notes: r.row(&quot;notes&quot;).append(newNote)}
).run(conn, callback)</code></pre>
<p><strong>Example:</strong> Send a note to every user with an ICQ number.</p>
<pre class="js"><code>var icqNote = {
    date: r.now(),
    from: &quot;Admin&quot;,
    subject: &quot;Welcome to the future&quot;
};
r.table(&quot;users&quot;).filter(
    r.row.hasFields({contact: {im: &quot;icq&quot;}})
).update(
    {notes: r.row(&quot;notes&quot;).append(icqNote)}
).run(conn, callback)</code></pre>
<p><strong>Example:</strong> Replace all of Bob's IM records. Normally, <code>update</code> will merge nested documents together; to replace the entire <code>&quot;im&quot;</code> document, use the <a href="/api/javascript/literal/">literal</a> command.</p>
<pre class="js"><code>r.table(&#39;users&#39;).get(10001).update(
    {contact: {im: r.literal({aim: &quot;themoosemeister&quot;})}}
).run(conn, callback)</code></pre>
</div>
</body>
</html>
